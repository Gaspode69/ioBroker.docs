---
translatedFrom: en
translatedWarning: Если вы хотите отредактировать этот документ, удалите поле «translationFrom», в противном случае этот документ будет снова автоматически переведен
editLink: https://github.com/ioBroker/ioBroker.docs/edit/master/docs/ru/dev/adapterjsonconfig.md
title: Конфигурация JSON ioBroker
hash: uvQuLv+B2UrVMpWA3t0/bd9VxY4hTapAX8U0J3lRgV0=
---
# Конфигурация JSON ioBroker
Admin (начиная с версии 6) поддерживает конфигурацию JSON для адаптеров.
Можно определить конфигурацию в файле JSON, а затем использовать ее в Admin.

Пример файла `jsonConfig.json` с несколькими вкладками можно найти здесь: https://github.com/ioBroker/ioBroker.admin/blob/master/admin/jsonConfig.json5, а пример с одной панелью — здесь: https://github.com/ioBroker/ioBroker.dwd/blob/master/admin/jsonConfig.json

Вы можете определить настройки в формате JSON или JSON5. JSON5 более удобен для чтения и поддерживает комментарии.

Кроме того, в файле JSON необходимо определить в части `io-package.json` в `common`:

```json
{
  "common": {
    "adminUI": {
      "config": "json"
    }
  }
}
```

сказать, что адаптер поддерживает конфигурацию JSON.

Вы можете увидеть почти все компоненты в действии, если протестируете этот адаптер: https://github.com/mcm4iob/ioBroker.jsonconfig-demo.
Вы можете установить его через значок GitHub в админке, введя `iobroker.jsonconfig-demo` на вкладке npm.

Схема для файла конфигурации JSON определена здесь: https://github.com/ioBroker/adapter-react-v5/blob/main/schemas/jsonConfig.json

Все метки, тексты, тексты справки могут быть многоязычными или просто строками.

*Если имя атрибута начинается с «_», оно не будет сохранено в объекте.*

## Включает
Требуется администратор 6.17.1 или более поздняя версия.

Для записи сложных файлов JSON вы можете включить другие файлы JSON.
Включенный файл должен находиться в том же каталоге, что и основной файл.

```json5
{
    "tabs": {
        "tab1": {
            "type": "panel", // data will be combined with the content of "tab1.json". If the same attribute is defined in both files, the value from the included file will be used.
            "#include": "tab1.json"
        }
    }
}
```

## Возможные типы управления
Возможные типы:

- `tabs` - Вкладки с элементами
- `items` - Объект с панелями `{"tab1": {}, "tab2": {}...}`
- `iconPosition` - `bottom`, `end`, `start` или `top`. Только для панелей с атрибутом `icon`. По умолчанию: `start`
- `tabsStyle` - стили CSS в формате React (`marginLeft`, а не `margin-left`) для компонента Mui-Tabs

- `panel` - Вкладка с элементами
- `icon` - вкладка может содержать значок (base64, например `data:image/svg+xml;base64,...`) или изображения `jpg/png` (заканчиваются на `.png`)
- `label` - Метка вкладки
- `items` - Объект `{"attr1": {}, "attr2": {}}...`
- `collapsable` - возможно только как часть вкладок[jsonConfig.json](..%2F..%2F..%2F..%2F..%2FioBroker.ring%2Fadmin%2FjsonConfig.json)
- `color` - цвет сворачиваемого заголовка `primary` или `secondary` или ничего
- `innerStyle` - CSS-стили для внутреннего div в формате React (`marginLeft`, а не `margin-left`) для компонента Panel. Не используется для сворачиваемых панелей.

- `text` - Текстовый компонент
- `maxLength` - максимальная длина текста в поле
- `readOnly` - поле только для чтения
- `trim` - по умолчанию true. Установите этот атрибут на `false`, если обрезка нежелательна.
- `minRows` - по умолчанию 1. Установите для этого атрибута значение `2` или больше, если вы хотите иметь текстовую область с более чем одной строкой.
- `maxRows` - максимальное количество строк текстовой области. Используется только если `minRows` > 1.
- `noClearButton` - если true, кнопка очистки не будет отображаться (admin >= 6.17.13)
- `validateJson` - если true, текст будет проверен как JSON
- `allowEmpty` - если true, JSON будет проверен только в том случае, если значение не пустое
- `time` - значение - время в мс или строка. Используется только с флагом readOnly

- `число`
- `min` - минимальное значение
- `max` - максимальное значение
- `шаг` - шаг

- `color` - выбор цвета
- `noClearButton` - если true, кнопка очистки не будет отображаться (admin >= 6.17.13)

- `checkbox` - показать флажок

- `slider` - показать слайдер (только Admin6)
- `min` - (по умолчанию 0)
- `макс` - (по умолчанию 100)
- `шаг` - (по умолчанию `(макс - мин) / 100`)
- `unit` - Единица измерения ползунка

- `qrCode` - отображение данных в QR-коде (по сравнению с Admin 7)
- `data` - данные, которые будут закодированы в QR-коде
- `size` - размер QR-кода
- `fgColor` - Цвет переднего плана
- `bgColor` - Цвет фона
- `level` - уровень QR-кода (`L` `M` `Q` `H`)

- `ip` - адрес привязки
- `listenOnAllPorts` - добавьте 0.0.0.0 к опции
- `onlyIp4` - показывать только адреса IP4
- `onlyIp6` - показывать только адреса IP6
- `noInternal` - не показывать внутренние IP-адреса

- `user` - Выбор пользователя из system.user. (С цветом и значком)
- `short` - нет системного пользователя.

- `room` - Выбрать комнату из `enum.room` (с цветом и значком) - (только Admin6)
- `short` - нет `enum.rooms.`
- `allowDeactivate` - разрешить оставлять комнату пустой

- `func` - Выбор функции из `enum.func` (с цветом и значком) - (только Admin6)
- `short` - нет `enum.func.`
- `allowDeactivate` - разрешить оставить функциональность пустой

- `выбрать`
- `options` - `[{label: {en: "option 1"}, value: 1}, ...]` или

                `[{"items": [{"label": "Val1", "value": 1}, {"label": "Val2", value: "2}], "name": "group1"}, {"items": [{"label": "Val3", "value": 3}, {"label": "Val4", value: "4}], "name": "group2"}, {"label": "Val5", "value": 5}]`

- `автозаполнение`
- `options` - `["value1", "value2", ...]` или `[{"value": "value", "label": "Value1"}, "value2", ...]` (ключи должны быть уникальными)
- `freeSolo` - Установите `freeSolo` в `true`, чтобы текстовое поле могло содержать любое произвольное значение.

- `image` - сохраняет изображение как файл объекта `adapter.X` или как base64 в атрибуте
- `filename` - имя файла - это имя структуры. В примере ниже `login-bg.png` - это имя файла для `writeFile("myAdapter.INSTANCE", "login-bg.png")`
- `accept` - атрибут принятия HTML, например `{ 'image/**': [], 'application/pdf': ['.pdf'] }`, по умолчанию `{ 'image/*': [] }`
- `maxSize` - максимальный размер файла для загрузки
- `base64` - если true, изображение будет сохранено как data-url в атрибуте, в противном случае как двоичное в файловом хранилище
- `crop` - если true, разрешить пользователю обрезать изображение
- `!максШирина`
- `!maxHeight`
- `!square` - ширина должна быть равна высоте, или обрезка должна допускать только квадратную форму

```
  "login-bg.png": {
       "type": "image",
       "accept": "image/png",
       "label": {
         "en": "Upload image"
       },
       "crop": true
     },
     "picture": {
       "type": "image",
       "base64": true,
       "accept": "image/*",
       "label": {
         "en": "Upload image"
       },
       "crop": true
     }
  }
```

- `objectId` - идентификатор объекта: показать его с именем, цветом и значком
- `types` - Желаемый тип: `channel`, `device`, ... (по умолчанию имеет только `state`). Множественное число, потому что `type` уже занято.
- `root` - [необязательно] Показывать только этот корневой объект и его дочерние объекты
- `customFilter` - [необязательно] Нельзя использовать вместе с настройками `type`. Это объект, а не строка JSON. Примеры
- `{common: {custom: true}}` - показывать только объекты с некоторыми пользовательскими настройками
- `{common: {custom: 'sql.0'}}` - показывать только объекты с пользовательскими настройками sql.0 (только определенного экземпляра)
- `{common: {custom: '_dataSources'}}` - показывать только объекты адаптеров `influxdb` или `sql` или `history`
- `{common: {custom: 'adapterName.'}}` - показывать только объекты пользовательских настроек определенного адаптера (все экземпляры)
- `{type: 'channel'}` - показать только каналы
- `{type: ['channel', 'device']}` - показывать только каналы и устройства
- `{common: {type: 'number'}` - показывать только состояния типа 'number'
- `{common: {type: ['number', 'string']}` - показывать только состояния типа 'number' и 'string'
- `{common: {role: 'switch'}` - показывать только состояния с ролями, начинающимися с switch
- `{common: {role: ['switch', 'button']}` - показывать только состояния с ролями, начинающимися с `switch` и `button`
- `filterFunc` - [необязательно] Нельзя использовать вместе с настройками `type`. Это функция, которая будет вызываться для каждого объекта и должна возвращать true или false. Пример: `obj.common.type === 'number'`

- `password` - поле пароля

Этот тип поля просто влияет на пользовательский интерфейс.
Пароли и другие конфиденциальные данные должны храниться в зашифрованном виде! Для этого ключ должен быть указан в io-package.json в [роднойЗашифрованный](https://github.com/ioBroker/ioBroker.js-controller#automatically-encryptdecrypt-configuration-fields).
Кроме того, вы можете защитить это свойство от обслуживания другими адаптерами, кроме `admin` и `cloud`, добавив его в `protectedNative` в файле `io-package.json`.

- `repeat` - повторный пароль необходимо сравнить с паролем
- `visible` - true, если разрешено просматривать пароль путем переключения кнопки просмотра (только для нового пароля при вводе)
- `readOnly` - флаг только для чтения. Visible автоматически становится истинным, если readOnly является истинным
- `maxLength` - максимальная длина текста в поле

- `экземпляр`
- `adapter` - имя адаптера. С помощью специального имени `_dataSources` можно получить все адаптеры с флагом `common.getHistory`.
- `adapters` - необязательный список адаптеров, которые должны быть показаны. Если не определено, будут показаны все адаптеры. Активно только если атрибут `adapter` не определен.
- `allowDeactivate` - если true. Показывается дополнительная опция "deactivate"
- `onlyEnabled` - если true. Будут показаны только включенные экземпляры
- `long` - значение будет выглядеть как `system.adapter.ADAPTER.0`, а не `ADAPTER.0`
- `short` - значение будет выглядеть как `0`, а не `ADAPTER.0`
- `all` - Добавить к параметрам параметр «all» со значением `*`

- `chips` - пользователь может ввести слово, и оно будет добавлено (см. облако => сервисы => Белый список). Вывод - массив, если `delimiter` не определен.
- `delimiter` - если он определен, то опция будет сохранена как строка с разделителем, а не как массив. Например, с помощью `delimiter=;` вы получите `a;b;c` вместо `['a', 'b', 'c']`

- `alive` - просто указание, активен ли экземпляр, и его можно использовать в состояниях «скрытый» и «отключенный» (не будет сохранено в конфигурации)

Просто текст: Экземпляр запущен, Экземпляр не запущен

- `instance` - проверка, активен ли экземпляр. Если не определен, будет использован текущий экземпляр. В тексте можно использовать шаблон `${data.number}`.
- `textAlive` - текст по умолчанию `Экземпляр %s жив`, где %s будет заменен на `ADAPTER.0`. Перевод должен существовать в файлах i18n
- `textNotAlive` - текст по умолчанию `Экземпляр %s не жив`, где %s будет заменен на `ADAPTER.0`. Перевод должен существовать в файлах i18n

- `pattern` - поле только для чтения с шаблоном типа 'https://${data.ip}:${data.port}' (не будет сохранено в конфигурации)

Ввод текста с флагом «только для чтения», отображающим шаблон.

- `copyToClipboard` - если true - показать кнопку
- `pattern` - мой шаблон

- `sendto` - кнопка, которая отправляет запрос экземпляру (https://github.com/iobroker-community-adapters/ioBroker.email/blob/master/admin/index_m.html#L128)
- `команда` - (по умолчанию `отправить`)
- `jsonData` - string - `"{\"subject1\": \"${data.subject}\", \"options1\": {\"host\": \"${data.host}\"}}"`. Вы можете использовать специальные переменные `data._origin` и `data._originIp` для отправки экземпляру URL-адреса вызывающего объекта, например `http://127.0.0.1:8081/admin`.
- `data` - object - `{"subject1": 1, "data": "static"}`. Можно указать jsonData или data, но не оба.
    - `result` - `{result1: {en: 'A'}, result2: {en: 'B'}}`
    - `error` - `{error1: {en: 'E'}, error2: {en: 'E2'}}`
- `вариант` - `содержащийся`, `очерченный` или ничего
- `openUrl` - если true - открыть URL в новой вкладке, если ответ содержит атрибут `openUrl`, например `{"openUrl": "http://1.2.3.4:80/aaa", "window": "_blank", "saveConfig": true}`. Если `saveConfig` - true, пользователю будет предложено сохранить конфигурацию.
- `reloadBrowser` - если true - перезагрузить текущее окно браузера, если ответ содержит атрибут `reloadBrowser`, например `{"reloadBrowser": true}`.
- `window` - если `openUrl` имеет значение true, это имя нового окна. Может быть перезаписано, если ответ содержит атрибут `window`.

`this.props.socket.sendTo(adapterName.instance, command || 'send', data, result => {});`

- `icon` - если значок должен быть показан: `auth`, `send`, `web`, `warning`, `error`, `info`, `search`. Вы можете использовать значки `base64` (например, `data:image/svg+xml;base64,...`) или изображения `jpg/png` (заканчиваются на `.png`). (Запросите через issue, если вам нужно больше значков)
- `useNative` - если адаптер возвращает результат с атрибутом `native`, он будет использован для конфигурации. Если `saveConfig` имеет значение true, пользователю будет предложено сохранить конфигурацию.
- `showProcess` - Показывать счетчик во время выполнения запроса
- `timeout` - таймаут для запроса в мс. По умолчанию: нет.
- `onLoaded` - выполнить логику кнопки один раз изначально

- `setState` - кнопка, устанавливающая состояние экземпляра
- `id` - `system.adapter.myAdapter.%INSTANCE%.test`, вы можете использовать заполнитель `%INSTANCE%`, чтобы заменить его на имя текущего экземпляра
- `ack` - false (по умолчанию false)
- `val` - '${data.myText}_test' или число. Тип будет определен автоматически из типа состояния и преобразование также выполнено
- `okText` - Оповещение, которое будет показано при нажатии кнопки
- `вариант` - `содержащийся`, `очерченный`, ''

- `staticText` - статический текст, как описание
- `label` - многоязычный текст
- `текст` - то же, что и метка

- `staticLink` - статическая ссылка
- `label` - многоязычный текст
- `href` - ссылка. Ссылка может быть динамической, например `#tab-objects/customs/${data.parentId}`
- `target` - `_blank` или `_self` или имя окна
- `close` - если true, GUI будет закрыт (используется не для JsonConfig в админке, а для динамического GUI)
- `button` - показать ссылку как кнопку
- `вариант` - тип кнопки (`контурная`, `содержащая`, `текстовая`)
- `color` - цвет кнопки (например, `primary`)
- `icon` - если значок должен быть показан: `auth`, `send`, `web`, `warning`, `error`, `info`, `search`, `book`, `help`, `upload`. Вы можете использовать значки `base64` (они начинаются с `data:image/svg+xml;base64,...`) или изображения `jpg/png` (заканчиваются на `.png`). (Запрос через issue, если вам нужно больше значков)

- `staticImage` - статическое изображение
- `href` - необязательная HTTP-ссылка
- `src` - имя картинки (из каталога администратора)

- `table` - таблица с элементами, которые можно удалять, добавлять, перемещать вверх, перемещать вниз
- `items` - `[{"type": см. выше, "width": px или %, "title": {"en": "header"}, "attr": "name", "filter": false, "sort": true, "default": ""}]`
- `noDelete` - логическое значение, если удаление или добавление отключены. Если `noDelete` равно false, то должны работать добавление, удаление и перемещение вверх/вниз.
- `objKeyName` - (устаревшая настройка, не использовать!) - имя ключа в `{"192.168.1.1": {delay: 1000, enabled: true}, "192.168.1.2": {delay: 2000, enabled: false}}`
- `objValueName` - (устаревшая настройка, не использовать!) - имя значения в `{"192.168.1.1": "value1", "192.168.1.2": "value2"}`
- `allowAddByFilter` - если добавление разрешено, даже если установлен фильтр
- `showSecondAddAt` - Количество строк, начиная с которых будет отображаться вторая кнопка добавления внизу таблицы. По умолчанию 5
- `showFirstAddOnTop` - Показывать первую кнопку «плюс» вверху первого столбца, а не слева.
- `clone` - [необязательно] - если кнопка клонирования должна быть показана. Если true, кнопка клонирования будет показана. Если имя атрибута, это имя будет уникальным.
- `export` - [необязательно] - если кнопка экспорта должна быть отображена. Экспортировать как файл csv.
- `import` - [необязательно] - если кнопка импорта должна быть отображена. Импорт из файла csv.
- `uniqueColumns` - [необязательно] - укажите массив столбцов, которые должны иметь уникальные записи
- `encryptedAttributes` - [необязательно] - укажите массив столбцов, которые следует зашифровать
- `compact` - [необязательно] - если true, таблица будет отображаться в компактном режиме

- `accordion` - аккордеон с элементами, которые можно удалять, добавлять, перемещать вверх, перемещать вниз (Admin 6.6.0 и новее)
- `items` - `[{"type": см. выше, "attr": "name", "default": ""}]` - элементы можно размещать как на `panel` (xs, sm, md, lg и newLine)
- `titleAttr` - ключ списка элементов, который следует использовать в качестве имени
- `noDelete` - логическое значение, если удаление или добавление отключены. Если `noDelete` равно false, то должны работать добавление, удаление и перемещение вверх/вниз.
- `clone` - [необязательно] - если кнопка клонирования должна быть показана. Если true, кнопка клонирования будет показана. Если имя атрибута, это имя будет уникальным.

- `jsonEditor` - редактор json
- `validateJson` - если false, текст не будет проверен как JSON
- `allowEmpty` - если true, JSON будет проверен только в том случае, если значение не пустое

- `язык` - выбрать язык
- `system` - разрешить использование системного языка из `system.config` по умолчанию (при выборе будет иметь пустое строковое значение)

- `сертификат`
- `certType` - один из: `public`, `private`, `chained`. Но с версии 6.4.0 можно использовать тип `certificates`.

- `certificates` - это универсальный тип, который управляет атрибутами `certPublic`, `certPrivate`, `certChained` и `leCollection`.

  Пример:

```json
{
   "_certs": {
       "type": "certificates",
       "newLine": true,
       "hidden": "!data.secure",
       "sm": 12
   }
}
  ```

- `certCollection` - выберите коллекцию сертификатов или просто используйте все коллекции или вообще не используйте Let's Encrypt.
- `leCollectionName` - имя коллекции сертификатов

- `пользовательский` (только Admin6)
- `name` — имя компонента, которое будет предоставлено через свойства, например ComponentInstancesEditor
- `url` - Расположение компонента
- `custom/customComponents.js`: в этом случае файлы будут загружены из `/adapter/ADAPTER_NAME/custom/customComponents.js`
- `https://URL/myComponent`: напрямую из URL
- `./adapter/ADAPTER_NAME/custom/customComponent.js`: в этом случае файлы будут загружены из `/adapter/ADAPTER_NAME/custom/customComponents.js`
- `i18n` - true, если файлы `i18n/xx.json` расположены в том же каталоге, что и компонент или объект перевода `{"text1": {"en": Text1"}}`

- `datePicker` - позволяет пользователю выбирать дату ввода, формат пользовательского интерфейса берется из настроенного `dateFormat` в установке пользователя.

компонент возвращает анализируемую строку даты.

- `timePicker` - позволяет пользователю выбрать дату, возвращаемая строка представляет собой анализируемую строку даты или имеет формат `ЧЧ:мм:сс`
- `format` - формат, передаваемый в средство выбора даты, по умолчанию равен `HH:mm:ss`
- `views` - Настройте, какие представления должны быть показаны пользователям. По умолчанию `['hours', 'minutes', 'seconds']`
- `timeSteps` - Представляет доступные временные шаги для каждого представления. По умолчанию `{ часы: 1, минуты: 5, секунды: 5 }`
- `returnFormat` - `fullDate` или `HH:mm:ss`. По умолчанию используется полная дата для обратной совместимости.

- `разделитель` - горизонтальная линия
- `height` - необязательная высота
- `color` - необязательный цвет разделителя или `primary`, `secondary`

- `заголовок`
- `текст`
- `размер` - 1-5 => h1-h5

- `cron`
- `complex` - показывать CRON с "минутами", "секундами" и т. д.
- `simple` - показать простые настройки CRON

- `fileSelector` (только Admin6)
- `pattern` - Шаблон расширения файла. Разрешено `**/*.ext` для показа всех файлов из подпапок, `*.ext` для показа из корневой папки или `folderName/*.ext` для показа всех файлов в подпапке `folderName`. По умолчанию `**/*.*`.
- `fileTypes` - [необязательно] тип файлов: `audio`, `image`, `text`
- `objectID` - Идентификатор объекта типа `meta`. Вы можете использовать специальный заполнитель `%INSTANCE%`: например `myAdapter.%INSTANCE%.files`
- `upload` - путь, где будут храниться загруженные файлы. Например, `folderName`. Если не определено, поле загрузки не будет показано. Чтобы загрузить в корень, установите это поле в `/`.
- `refresh` - Показывать кнопку обновления рядом с выбором.
- `maxSize` - максимальный размер файла (по умолчанию 2 МБ)
- `withFolder` - показывать имя папки, даже если все файлы находятся в одной папке
- `delete` - Разрешить удаление файлов
- `noNone` - Не показывать опцию `none`
- `noSize` - Не показывать размер файлов

- `file` (только Admin6)

Поле ввода с селектором файлов

- `disableEdit` - если пользователь может вручную ввести имя файла, а не только через диалог выбора
- `limitPath` - ограничить выборку одним конкретным объектом типа `meta` и следующим путем (не обязательно)
- `filterFiles` - например `['png', 'svg', 'bmp', 'jpg', 'jpeg', 'gif']`
- `allowUpload` - разрешена загрузка файлов
- `allowDownload` - разрешено скачивание файлов (по умолчанию true)
- `allowCreateFolder` - разрешено создание папок
- `allowView` - разрешен просмотр плиток (по умолчанию true)
- `showToolbar` - показать панель инструментов (по умолчанию true)
- `selectOnlyFolders` - пользователь может выбрать только папки (например, для пути загрузки)
- `trim` - обрезать имя файла

- `imageSendTo` - показывает изображение, полученное от бэкэнда в виде строки base64
- `width` - ширина QR-кода в пикселях
- `height` - высота QR-кода в пикселях
- `команда` - команда sendTo
- `jsonData` - string - `{"subject1": "${data.subject}", "options1": {"host": "${data.host}"}}`. Эти данные будут отправлены на бэкэнд
- `data` - object - `{"subject1": 1, "data": "static"}`. Вы можете указать jsonData или data, но не оба. Эти данные будут отправлены на бэкэнд, если jsonData не определен.

Пример кода в бэкэнде:

```
adapter.on('message', obj => {
    if (obj.command === 'send') {
        const QRCode = require('qrcode');
        QRCode.toDataURL('3ca4234a-fd81-fdb8-5584-08c732f70e4d', (err, url) =>
            obj.callback && adapter.sendTo(obj.from, obj.command, url, obj.callback));
    }
});
```

- `selectSendTo`

Показывает раскрывающееся меню с указанными значениями экземпляра.

- `команда` - команда sendTo
- `jsonData` - string - `{"subject1": "${data.subject}", "options1": {"host": "${data.host}"}}`. Эти данные будут отправлены на бэкэнд
- `data` - object - `{"subject1": 1, "data": "static"}`. Вы можете указать jsonData или data, но не оба. Эти данные будут отправлены на бэкэнд, если jsonData не определен.
- `manual` - разрешить ручное редактирование. Без выпадающего меню (если экземпляр находится в автономном режиме). По умолчанию `true`.
- `multiple` - выбор множественного выбора
- `showAllValues` - показать элемент, даже если для него не найдено ни одной метки (по нескольким), по умолчанию=`true`
- `noTranslation` - не переводить метки выбора

Чтобы использовать эту опцию, ваш адаптер должен реализовать обработчик сообщений: Результатом команды должен быть массив в форме `[{"value": 1, "label": "one"}, ...]`

- `alsoDependsOn` - при изменении каких атрибутов команда должна быть отправлена повторно

```
adapter.on('message', obj => {
   if (obj) {
       switch (obj.command) {
           case 'command':
               if (obj.callback) {
                   try {
                       const { SerialPort } = require('serialport');
                       if (SerialPort) {
                           // read all found serial ports
                           SerialPort.list()
                               .then(ports => {
                                   adapter.log.info(`List of port: ${JSON.stringify(ports)}`);
                                   adapter.sendTo(obj.from, obj.command, ports.map(item => ({label: item.path, value: item.path})), obj.callback);
                               })
                               .catch(e => {
                                   adapter.sendTo(obj.from, obj.command, [], obj.callback);
                                   adapter.log.error(e)
                               });
                       } else {
                           adapter.log.warn('Module serialport is not available');
                           adapter.sendTo(obj.from, obj.command, [{label: 'Not available', value: ''}], obj.callback);
                       }
                   } catch (e) {
                       adapter.sendTo(obj.from, obj.command, [{label: 'Not available', value: ''}], obj.callback);
                   }
               }

               break;
       }
   }
});
```

- `autocompleteSendTo`

Показывает элемент управления автозаполнением с указанными в экземпляре значениями.

- `команда` - команда sendTo
- `jsonData` - string - `{"subject1": "${data.subject}", "options1": {"host": "${data.host}"}}`. Эти данные будут отправлены на бэкэнд
- `data` - object - `{"subject1": 1, "data": "static"}`. Вы можете указать jsonData или data, но не оба. Эти данные будут отправлены на бэкэнд, если jsonData не определен.
- `freeSolo` - Установите `freeSolo` в `true`, чтобы текстовое поле могло содержать любое произвольное значение.
- `alsoDependsOn` - при изменении каких атрибутов команда должна быть отправлена повторно
- `maxLength` - максимальная длина текста в поле

Чтобы использовать эту опцию, ваш адаптер должен реализовать обработчик сообщений: Результатом команды должен быть массив в форме `["value1", {"value": "value2", "label": "Value2"}, ...]` (ключи должны быть уникальными) Пример обработчика см. в `selectSendTo`

- `textSendTo`

Показывает элемент управления только для чтения с указанными в экземпляре значениями.

- `container` - div, текст, html
- `copyToClipboard` - если true - показать кнопку
- `alsoDependsOn` - при изменении каких атрибутов команда должна быть отправлена повторно
- `команда` - команда sendTo
- `jsonData` - string - `{"subject1": "${data.subject}", "options1": {"host": "${data.host}"}}`. Эти данные будут отправлены на бэкэнд
- `data` - object - `{"subject1": 1, "data": "static"}`. Вы можете указать jsonData или data, но не оба. Эти данные будут отправлены на бэкэнд, если jsonData не определен.

Чтобы использовать эту опцию, ваш адаптер должен реализовать обработчик сообщений: Результатом команды должна быть строка или объект со следующими параметрами:

```
{
    text: 'text to show',  // mandatory
    style: {color: 'red'}, // optional
    icon: 'search',        // optional. It could be base64 or link to image in the same folder as jsonConfig.json file
                           // possible predefined names: edit, rename, delete, refresh, add, search, unpair, pair, identify, play, stop, puase, forward, backward, next, previous, lamp, backlight, dimmer, socket, settings, group, user, qrcode, connection, no-connection, visible
    iconStyle: {width: 30} // optional
}
```

Пример:

```
adapter.on('message', obj => {
    if (obj) {
      switch (obj.command) {
        case 'command':
          obj.callback && adapter.sendTo(obj.from, obj.command, 'Received ' + JSON.stringify(obj.message), obj.callback);
          // or with style
          obj.callback && adapter.sendTo(obj.from, obj.command, { text: 'Received ' + JSON.stringify(obj.message), style: { color: 'red' }, icon: 'search', iconStyle: { width: 30 }}, obj.callback);
          // or as html
          obj.callback && adapter.sendTo(obj.from, obj.command, `<div style="color: green">${JSON.stringify(obj.message)}</div>`, obj.callback);
          break;
      }
    }
});
```

- `координаты`

Определяет текущее местоположение и использует координаты `system.config`, если это невозможно в формате «широта,долгота»

- `divider` - разделитель между широтой и долготой. По умолчанию "," (используется, если longitudeName и latitudeName не определены)
- `autoInit` - инициализирует поле текущими координатами, если пусто
- `longitudeName` - если определено, долгота будет сохранена в этом атрибуте, разделитель будет проигнорирован
- `latitudeName` - если определено, широта будет сохранена в этом атрибуте, разделитель будет проигнорирован
- `useSystemName` - если определено, будет показан флажок «Использовать системные настройки», а широта и долгота будут считаны из `system.config`, логическое значение будет сохранено под указанным именем

- `интерфейс`

Выбирает интерфейс хоста, на котором запущен экземпляр

- `ignoreLoopback` - не показывать интерфейс обратной связи (127.0.0.1)
- `ignoreInternal` - не показывать внутренние интерфейсы (обычно это тоже 127.0.0.1)

- `license` - показывает информацию о лицензии, если она еще не принята. Один из атрибутов `texts` или `licenseUrl` должен быть определен. Когда лицензия принята, определенный атрибут конфигурации будет установлен в `true`.
- `texts` - массив абзацев с текстами, которые будут показаны каждый как отдельный абзац
- `licenseUrl` - URL-адрес файла лицензии (например, https://raw.githubusercontent.com/ioBroker/ioBroker.docs/master/LICENSE)
- `title` - Заголовок диалогового окна лицензии
- `agreeText` - Текст кнопки согласия
- `checkBox` - Если определено, будет показан флажок с указанным именем. Если отмечено, будет включена кнопка согласования.

- `checkLicense` - Очень специальный компонент для проверки лицензии онлайн. Требуются именно свойства `license` и `useLicenseManager` в нативном коде.
- `uuid` - Проверка UUID
- `версия` - Проверить версию

- `uuid` - Показать UUID iobroker

- `port` - Специальный ввод для портов. Он автоматически проверяет, используется ли порт другими экземплярами, и выводит предупреждение
- `min` - минимально допустимый номер порта. Может быть 0. И если значение равно нулю, то проверка на занятость порта не произойдет.

-

- `state` - Показать элемент управления или информацию из состояния
- `oid` - Какой идентификатор объекта следует взять для управления. Идентификатор не имеет префикса "adapter.X."
- `system` - Если true, состояние будет взято из system.adapter.XX.I., а не из XX.I.
- `control` - Как должно отображаться значение состояния: `text`, `html`, `input`, `slider`, `select`, `button`, `switch`, `number`
- `controlled` - Если true, состояние будет отображаться как переключатель, выбор, кнопка, ползунок или ввод текста. Используется только если не определено свойство управления
- `unit` - Добавить единицу измерения к значению
- `trueText` - этот текст будет показан, если значение равно true
- `trueTextStyle` - Стиль текста, если значение равно true
- `falseText` - этот текст будет показан, если значение равно false или если элемент управления является «кнопкой»
- `falseTextStyle` - Стиль текста, если значение равно false или если элемент управления является «кнопкой»
- `trueImage` - Это изображение будет показано, если значение равно true
- `falseImage` - Это изображение будет показано, если значение равно false или если элемент управления является «кнопкой».
- `min` - Минимальное значение для типа элемента управления: ползунок или число
- `max` - Максимальное значение для типа элемента управления: ползунок или число
- `step` - Значение шага для типа элемента управления: ползунок или число
- `controlDelay` - задержка в мс для ползунка или числа
- `variant` - Вариант кнопки: `contained`, `outlined`, `text`

- `deviceManager` - показать диспетчер устройств. Для этого адаптер должен поддерживать протокол диспетчера устройств. См. iobroker/dm-utils.

Вот пример того, как отобразить диспетчер устройств на вкладке:

```
"_deviceManager": {
  "type": "panel",
  "label": "Device manager",
  "items": {
    "_dm": {
      "type": "deviceManager",
      "sm": 12,
      "style": {
        "width": "100%",
        "height": "100%",
        "overflow": "hidden"
      }
    }
  },
  "style": {
    "width": "100%",
    "height": "100%",
    "overflow": "hidden"
  },
  "innerStyle": {
    "width": "100%",
    "height": "100%",
    "overflow": "hidden"
  }
}
```

## Общие атрибуты элементов управления
Все типы могут иметь:

- `sm` - ширина в 1/12 экрана на маленьком экране
- `md` - ширина в 1/12 экрана на средних экранах
- `lg` - ширина в 1/12 экрана на больших экранах
- `xs` - ширина в 1/12 экрана на маленьких экранах
- `newLine` - следует отображать с новой строки
- `label` - Строка или объект типа {en: 'Name', ru: 'Имя'}
- `hidden` - функция JS, которая может использовать `native.attribute` для вычислений
- `hideOnlyControl` - если скрыто, то место будет показано, но без управления
- `disabled` - функция JS, которая может использовать `native.attribute` для вычислений
- `help` - текст справки (многоязычный)
- `helpLink` - href для справки (может использоваться только вместе с `help`)
- `style` - стиль css в нотации ReactJS: `radiusBorder`, а не `radius-border`.
- `darkStyle` - css-стиль для темного режима
- `validator` - функция JS: true - нет ошибки, false - ошибка
- `validatorErrorText` - Текст, отображаемый в случае сбоя валидатора
- `validatorNoSaveOnError` - отключить кнопку сохранения в случае ошибки
- `tooltip` - необязательная подсказка
- `default` - значение по умолчанию
- `defaultFunc` - функция JS для вычисления значения по умолчанию
- `defaultSendTo` - команда для запроса начального значения у запущенного экземпляра, пример: `"myInstance": {"type": "text", "defaultSendTo": "fill"}`
- `data` - статические данные
- `jsonData` - статические данные
- если не определены `data` и `jsonData`, будет отправлена следующая информация `{"attr": "<имя атрибута>", "value": "<текущее значение>"}`
- `button` - метка кнопки для повторного запуска запроса из экземпляра
- `buttonTooltip` - Подсказка кнопки (по умолчанию: `Запросить данные по экземпляру`)
- `buttonTooltipNoTranslation` - Не переводить подсказку кнопки
- `allowSaveWithError` - Разрешить сохранение конфигурации, даже если экземпляр находится в автономном режиме
- `placeholder` - заполнитель (для управления текстом)
- `noTranslation` - не переводить выбранные или другие параметры (не для справки, метки или заполнителя)
- `onChange` - Структура в форме `{"alsoDependsOn": ["attr1", "attr2"], "calculateFunc": "data.attr1 + data.attr2", "ignoreOwnChanges": true}`
- `doNotSave` - Не сохранять этот атрибут, так как он используется только для внутренних расчетов.
- `noMultiEdit` — если этот флаг установлен в значение true, это поле не будет отображаться, если пользователь выбрал более одного объекта для редактирования.
- `подтвердить`
- `condition` - функция JS: true показать диалог подтверждения
- `text` - текст диалога подтверждения
- `title` - заголовок диалога подтверждения
- `ok` - Текст для кнопки ОК
- `cancel` - Текст для кнопки «Отмена»
- `type` - Один из: `info`, `warning`, `error`, `none`
- `alsoDependsOn` - массив с атрибутами, для проверки условия и по этим атрибутам

```
{
    "type": "tabs",
    "items": {
        "options1": {
            "type": "panel",
            "label": "Tab1",
            "icon": "base64 svg", // optional
            "items": {
                myPort: {
                    "type": "number",
                    "min": 1,
                    "max": 65565,
                    "label": "Number",
                    "sm": 6, // 1 - 12
                    "validator": "'"!!data.name"'", // else error
                    "hidden": "data.myType === 1", // hidden if myType is 1
                    "disabled": "data.myType === 2" // disabled if myType is 2
                },
                "options.myType": { // name could support more than one levelhelperText
                    "newLine": true, // must start from new row
                    "type": "select",
                    "label": "Type",
                    "sm": 6, // 1 - 12
                    "options": [
                        {"label": "option 1", "value": 1},
                        {"label": "option 2", "value": 2}
                    ]
                },
                "myBool": {
                    "type": "checkbox",
                    "label": "My checkbox",
                }
            }
        },
        "tab2": {
            "label": "Tab2",
            "disabled": "data.myType === 1",
            "hidden": "data.myType === 2",
        }
    },
}
```

`Number`, `text`, `checkbox`, `select` поддерживают автозаполнение, чтобы разрешить выбор параметров при использовании в качестве пользовательских настроек.
В этом случае значение будет предоставлено как массив всех возможных значений.

Пример:

```
...
   "timeout": {
      "type": "number",
      "label": "Timeout"
   }
...

data: {
   timeout: [1000, 2000, 3000]
}
```

В этом случае ввод должен быть текстовым, где показано `__different__`, с возможностью автозаполнения трех возможных значений.
Пользователи могут выбрать из раскрывающегося списка 1000, 2000 или 3000 или ввести собственное новое значение, например, 500.

Булевое значение должно поддерживать неопределенность, если значение равно [false, true]

Для неизмененного `__different__` должно быть возвращено другое значение:

```
Input:
data: {
   timeout: [1000, 2000, 3000]
}

Output if timeout was not changed:
newData: {
   timeout: "__different__"
}
```

Значение `__different__` зарезервировано, и ни один текстовый ввод не может принять его от пользователя.

Компонент должен выглядеть так

```
<SchemaEditor
    style={customStyle}
    className={classes.myClass}
    schema={schema}
    customInstancesEditor={CustomInstancesEditor}
    data={common.native}
    onError={(error, attribute) => error can be true/false or text. Attribute is optional}
    onChanged={(newData, isChanged) => console.log('Changed ' + isChanged)}
/>
```

Если схема не указана, ее необходимо создать автоматически из данных.

- `boolean` => флажок
- `текст` => ввод текста
- `число` => число
- имя `bind` => ip
- имя `port` => номер, мин=1, макс=0xFFFF
- имя `timeout` => число, help="ms"

Если элемент не имеет атрибута `type`, предполагается, что он имеет тип по умолчанию «панель».

## Стиль панели
Вы также можете задать стиль для панелей. Вот пример с фоном панели:

```json
{
  "i18n": true,
  "type": "panel",
  "style": {
    "backgroundImage": "url(adapter/mpd/background.png)",
    "backgroundPosition": "top",
    "backgroundRepeat": "no-repeat",
    "backgroundSize": "cover"
  },
  "items": {
    "...": {}
  }
}
```

## Интернациональный
Существует несколько вариантов предоставления переводов.
Только первый из них совместим с нашим инструментом перевода сообщества Weblate, поэтому его следует предпочесть другим!

1. Пользователи могут предоставлять тексты из файлов.

На верхнем уровне структуры установите `i18n: true` и предоставьте файлы в администраторе:

- `admin/i18n/de/translations.json`
- `admin/i18n/en/translations.json`
- ...

или

- `admin/i18n/de.json`
- `admin/i18n/en.json`
- ...

Кроме того, пользователь может указать путь к файлам i18n, `i18n: "customI18n"`и указать файлы в админке:

- `admin/customI18n/de/translations.json`
- `admin/customI18n/en/translations.json`
- ...

или

- `admin/customI18n/de.json`
- `admin/customI18n/en.json`
- ...

2. Пользователь может предоставить переводы непосредственно в метке, например:

```
{
   "type": "text",
   "label: {
        "en": "Label",
        "de": "Taxt"
    }
}
```

3. Пользователь может предоставить переводы в атрибуте i18n:

```
{
    "18n": {
        "My Text: {
            "en": "My Text",
            "de": "Mein Text"
        },
        "My Text2: {
            "en": "My Text2",
            "de": "Mein Text2"
        },
    },
    "type": "panel",
    ...
}
```

Мы рекомендуем по возможности использовать вариант 1, так как в этом случае тексты можно будет обрабатывать с помощью Weblate.

## Функции JS
### Диалоговое окно конфигурации
Функция JS:

```
const myValidator = "_alive === true && data.options.myType == 2";

const func = new Function(
  'data',          // actual obj.native or obj.common.custom['adapter.X'] object
                   // If table, so data is current line in the table
  'originalData',  // data before changes
  '_system',       // system config => 'system.config'=>common
  '_alive',        // If instance is alive
  '_common',       // common part of instance = 'system.config.ADAPTER.X' => common
  '_socket',       // socket connection
  '_instance',     // instance number
  'arrayIndex',    // filled only by table and represents the row index
  'globalData',    // filled only by table and represents the obj.native or obj.common.custom['adapter.X'] object
  '_changed'       // indicator if some data was changed and must be saved
  myValidator.includes('return') ? myValidator : 'return ' + myValidator); // e.g. "_alive === true"

const isValid = func(data, systemConfig.common, instanceAlive, adapter.common, this.props.socket);

```

Если статус `alive` изменится, все поля должны быть обновлены, проверены, отключены, скрыты заново.

В настройках адаптера функции JS доступны следующие переменные:

- `data` - собственные настройки для данного экземпляра или текущей строки в таблице (для доступа ко всем настройкам используйте globalData)
- `_system` - конфигурация системы
- `_alive` - экземпляр живой
- `_common` - общие настройки для этого экземпляра
- `_socket` - сокет
- `_instance` - номер экземпляра
- `arrayIndex` - используется только в таблице и представляет текущую строку в массиве
- `globalData` - используется только в таблице для всех настроек, а не только в одной строке таблицы

### Диалоговое окно пользовательских настроек
Функция JS:

```
const myValidator = "customObj.common.type === 'boolean' && data.options.myType == 2";

const func = new Function(
  'data',
  'originalData',
  '_system',
  'instanceObj',
  'customObj',
  '_socket',
  arrayIndex,
  myValidator.includes('return') ? myValidator : 'return ' + myValidator); // e.g. "_alive === true"

const isValid = func(data || this.props.data, this.props.originalData, this.props.systemConfig, instanceObj, customObj, this.props.socket);
```

В пользовательских настройках функции JS доступны следующие переменные:

- `data` - текущие пользовательские настройки или текущая строка в таблице (для доступа ко всем настройкам используйте globalData)
- `originalData` - Неизмененные данные
- `_system` - конфигурация системы
- `instanceObj` - объект экземпляра адаптера
- `customObj` - сам текущий объект
- `_socket` - сокет
- `arrayIndex` - используется только в таблице и представляет текущую строку в массиве
- `globalData` - используется только в таблице для всех настроек, а не только в одной строке таблицы

## Пользовательский компонент
```
<CustomInstancesEditor
    common={common data}
    alive={isInstanceAlive}
    data={data}
    socket={this.props.socket}
    themeName={this.props.themeName}
    themeType={this.props.themeType}
    theme={this.props.theme}
    name="accessAllowedConfigs"
    onChange={(newData, isChanged) => {}}
    onError={error => error can be true/false or text}
/>
```

Примеры можно найти в адаптере [`telegram`](https://github.com/iobroker-community-adapters/ioBroker.telegram/tree/master/src-admin) или в [`pushbullet`](https://github.com/Jens1809/ioBroker.pushbullet/tree/master/src-admin).

## Схема
Схема [здесь](https://github.com/ioBroker/adapter-react-v5/tree/master/schemas)